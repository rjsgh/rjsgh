# # def print_kwargs(**kwargs):
# #     print(kwargs)
# # print_kwargs(a = 1, b = "banana")

#4673번 셀프 넘버
# 나(길이가 김. sum과 map 함수를 이용해 줄일 수 있음)
# def d(n):
#     a = n
#     if a < 1001:
#         a = n + n%10 + n//10
#     elif a > 1000:
#         while n != 0:
#             a =  a + n%10
#             n = n//10
#     return a
# b = []
# for i in range(0,10000):
#     b.append(d(i))
#
# for i in range(0,10000):
#     if i not in b:
#         print(i)

# 풀이
# def d(n):
#     n = n+sum(map(int,str(n))) #각 자리마다 더해주는 함수 ; sum(map(int,str(n)))
#     return n
#
# n_self_num = set()  #중복 없애주기. 교집합 합집합.
# for i in range(1,10001):
#     n_self_num.add(d(i))
#
# for j in range(1,10001):
#     if j not in n_self_num:
#         print(j)

#1065 한수
# 다시 한번 풀어보기

# 나(미완)
# a = 0
# def hansoo(n):
#     if :
#         n+=1
#         if n >= 100:
#             break
#     print(n)
#     return a
# print(hansoo(50))

# 풀이
# def isHansu(n):
#     cnt = 0     #count개수
#     for i in range(1, n+1):
#         if i <100:
#             cnt += 1                # 한수의 개수 추가
#         elif i % 10 - i // 10 % 10 == i // 10 % 10 - i // 10 // 10: #i가 100부터 999까지
#             # 1의 자리 - 10의 자리 = 10의 자리 - 100의 자리 인 경우 i는 한수 이므로
#             cnt += 1      # 한수의 개수 추가.
#     print(cnt)
# n = int(input())
# isHansu(n)

#프로그래머스 로또의 최고 순위와 최저 순위

# 나
#lottos [44, 1, 0, 0, 31, 25] #win_nums [31, 10, 45, 1, 6, 19] 출력 : [3,5]
# a = 0
# def solution(lottos, win_nums):
#     answer = []
#     return answer
#
# lottos = [44, 1, 0, 0, 31, 25]
# win_nums = [31, 10, 45, 1, 6, 19]
#
# if set(lottos)&set(win_nums):
#     print(set(lottos)&set(win_nums))
# else:
#     pass

# 풀이
# lottos = [44, 1, 0, 0, 31, 25]
# win_nums = [31, 10, 45, 1, 6, 19]
# def solution(lottos, win_nums):
#     ran = [6,6,5,4,3,2,1] #0~1개 맞추면 6위, 2개 맞추면 5위...6개 모두 맞추면 1위
#     a = len(set(lottos) & set(win_nums)) + lottos.count(0) #최대 맞힌 개수
#     b = len(set(lottos) & set(win_nums))                   #최소 맞힌 개수
#     answer =[rank[a],rank[b]]
#     return answer
# print()


#계산기 만들기
# class Fourcal:
#     def __init__(self):
#         self.result = 0
#
#     def add(self,num):
#         self.result += num
#         return self.result
#
#     def sub(self,num):
#         self.result -= num
#         return self.result
#
#     def mul(self,num):
#         self.result *= num
#         return self.result
#
#     def div(self,num):
#         self.result /= num
#         return self.result
# cal1 = Fourcal()
# print(cal1.add(3))
# print(cal1.add(4))
# cal2 = Fourcal()
# print(cal2.add(2))
# print(cal2.add(8))
# cal3 = Fourcal()
# print(cal3.add(10))
# print(cal3.sub(2))
# print(cal3.mul(3))
# print(cal3.div(4))

#계산기 만들기2
# class Fourcal:
    # def __init__(self,first,second):
    #     self.first = first
    #     self.second = second
    #
    # def add(self):
    #     result = self.first + self.second
    #     return result
    #
    # def sub(self):
    #     result = self.first - self.second
    #     return result
    #
    # def mul(self):
    #     result = self.first * self.second
    #     return result
    #
    # def div(self):
    #     result = self.first / self.second
    #     return result


# class Fourcal:
#     def __init__(self):
#         self.result = 0
#
#     def add(self,num):
#         self.result += num
#         return self.result
#
#     def sub(self,num):
#         self.result -= num
#         return self.result
#
#     def mul(self,num):
#         self.result *= num
#         return self.result
#
#     def div(self,num):
#         self.result /= num
#         return self.result
#
# class MoreFourcal(Fourcal):
#     def __add__(self, other):
#         new_cal = MoreFourcal()
#         new_cal.result = self.result + other.result
#         return new_cal
#
# cal1 = MoreFourcal()
# cal2 = MoreFourcal()
# cal1.add(10)
# cal2.add(3)
# cal3 = cal1 + cal2
# print(cal3.result)


#클래스의 상속

# class MoreFourcal(Fourcal):
#     def pow(self):
#         self.result = self.first ** self.second
#         return self.result
#
#     def add(self):             # 부모 클래스에서 상속받은 기능을 자식 클래스에서 추가적으로 변형시키는 기능(매쏘드 오버라이딩)
#         return super().add()   # super().add == Fourcal().add()
#
#     def __add__(self,other):
#         new_cal = MoreFourcal()
#         new_cal.result = self.result + other.result
#         return new_cal.result


# mcal1 = MoreFourcal(10,2)
# mcal2 = MoreFourcal(3,4)
# mcal3 = mcal1 + mcal2
# print(mcal3)

#프로그래머스 없는 숫자 더하기
# numbers = [1,2,3,4,6,7,8,0]
# def solution(numbers):
#     answer = 0
#     b = []
#     for i in range(0, 10):
#         if i not in numbers:
#             b.append(i)
#     answer += sum(b)
#     return answer
# print(solution(numbers))

#프로그래머스 신규 아이디 추천
# new_id = "=.="
# def solution(new_id):
#     answer = ''
#     #1번
#     new_id = new_id.lower()
#     #2번
#     for c in new_id:
#         if c.isalpha() or c.isdigit() or c in ['-','_','.']:   # isalpha,isdigit에 각각 숫자,문자가 들어가면 True
#             answer += c                                                                # 들어가지 않으면 False가 출력됨
#     #3번
#     while '..' in answer:
#         answer = answer.replace('..','.')
#     #4번
#     answer = answer.strip('.')
#     # if answer[0] == '.':              #
#     #     answer = answer[1:]
#     # if answer[-1] == '.':
#     #     answer = answer[:-1]
#     #5번
#     if answer == '':
#         answer += 'a'
#     #6번
#     if len(answer) > 15:
#         answer = answer[:15]
#         if answer[-1] == '.':
#             answer = answer[:-1]
#     #7번
#     while len(answer) < 3:
#         answer += answer[-1]
#     return answer
# print(solution(new_id))

#풀이
# new_id = "=.="
# def solution(new_id):
#     answer = ''
#     #1번
#     new_id = new_id.lower()
#     #2번
#     s_word = "~!@#$%^&*()=+[{]}:?,<>/"
#     for i in range(len(new_id)):
#         if new_id[i] not in s_word:
#             answer += new_id[i]
#     #3번
#     while '..' in answer:
#         answer = answer.replace('..','.')
#     #4번
#     answer = answer.strip('.')
#     #5번
#     if len(answer) == 0:
#         answer += 'a'
#     #6번
#     if len(answer) >= 16:
#         answer = answer[:15]
#         if answer.endswith('.'):
#             answer = answer[:-1]
#     #7번
#     if len(answer) < 3:
#         while len(answer) < 3:
#             answer += answer[-1]
#     return answer
# print(solution(new_id))

#자료 구조(스택)

# class StackElement:
#     def __init__(self,data,next):
#         self.data = data
#         self.next = next

# class Stack:
#     #생성자 생성 == 초기값
#     def __init__(self):
#         self.top = None
#
#     def push(self,data):
#         if self.top == None:    # stack에 data가 없는 경우
#             elem = StackElement(data,None)
#             self.top = elem
#         else:                   # stack에 data가 1개 이상 있는 경우
#             elem = StackElement(data,self.top)
#             self.top = elem
#     def pop(self):
#         if self.top == None:        # stack에 data가 없을 때
#             return None
#         else:                       # stack에 data가 1개 이상 있을 때
#             temp = self.top         # temp로 top을 바인딩
#             self.top = temp.next        # temp의 next를 top으로 바꿔줌 == top의 next 위치를 깔끔하게 뽑아내기 위해서.
#             return temp.data
#     def peak(self):
#         if self.top == None:
#             return None
#         else:
#             return self.top.data

# s1 = Stack()
# for i in range(1,4):
#     s1.push(i)
#     print(s1.peak())
# for i in range(3):
#     print(s1.pop())

#백준 10828번 스택
# N = int(input())
# class StackElement:
#     def __init__(self,data,next):
#         self.data = data
#         self.next = next
# class Stack:
#     def __init__(self):
#         self.top = None
#
#     def push_X(self,data):
#         if self.top == None:
#             elem = StackElement(data,None)
#             self.top = elem
#         else:
#             elem = StackElement(data,self.top)
#             self.top = elem
#     def pop(self):
#         if self.top == None:
#             return -1
#         else:
#             temp = self.top
#             self.top = temp.next
#             return temp.data
#     def size(self):
#         size = 0
#         for i in range(N):
#             size += len(self.data)
#             return size
#     def empty(self):
#         if self.top == None:
#             return 1
#         else:
#             return 0
#     def top(self):
#         if self.top == None:
#             return -1
#         else:
#             self.top = temp
#             return temp.data
# s1 = Stack()
# s1.push_X(1)
# s1.push_X(2)
# s1.push_X(3)
# print(s1.size())
# for i in range(N):
#     input()

#풀이
# class StackElement:
#     def __init__(self,data,next):
#         self.data = data
#         self.next = next
# class Stack:
#     def __init__(self):
#         self.top = None
#         self.size = 0
#     def push(self,data):
#         if self.top == None:
#             elem = StackElement(data,None)
#             self.top = elem
#             self.size += 1
#         else:
#             elem = StackElement(data,self.top)
#             self.top = elem
#             self.size += 1
#
#     def pop(self):
#         if self.top == None:
#             return -1
#         else:
#             temp = self.top
#             self.top = temp.next
#             self.size -= 1
#             return temp.data
#
#     def peek(self):
#         if self.top is None:
#             return -1
#         else:
#             return self.top.data
#
#     def empty(self):
#         if self.top == None:
#             return 1
#         else:
#             return 0
#
#     def __len__(self):
#         return self.size
#
# N = int(input())
# s1 = Stack()
# for i in range(N):
#     command = input().split()
#     if command[0] == 'push':
#         s1.push(command[1])
#     elif command[0] == 'top':
#         print(s1.peek())
#     elif command[0] == 'size':
#         print(len(s1))
#     elif command[0] == 'empty':
#         print(s1.empty())
#     elif command[0] == 'pop':
#         print(s1.pop())

#프로그래머스 기능개발
# progresses = [95, 90, 99, 99, 80, 99]
# progresses = [93, 30, 5]
# speeds = [1, 1, 1, 1, 1, 1]
# speeds = [1, 30, 5]
# day = [0]
# answer = []
#
# def solution(progresses, speeds):
#     for i in range(len(progresses)):
#         day.insert(i+1,0)
#         answer.insert(i,0)
#         if day[i] >= day[i+1]:
#             answer[0] += 1
#         while True:
#             if progresses[i] >= 100:
#                 answer.insert(i, 0)
#                 break
#             else:
#                 progresses[i] += speeds[i]
#                 day[i] += 1
#     for i in range(len(answer)):
#         if 0 in answer:
#             answer.remove(0)
#     day.remove(0)
#     return answer
# print(solution(progresses,speeds))

#풀이
# def solution(progresses,speeds):
#     #기능별로 배포 까지 걸리는 기간 구하기
#     terms = []      #기간들
#     for i in range(len(progresses)):
#         cnt = 0             #걸리는 일 수
#         while progresses[i] < 100:              #기능이 100프로가 될 때까지
#             progresses[i] += 1*speeds[i]        #기능 += 속도
#             cnt += 1                        #하루가 지남
#         terms.append(cnt)
#     terms.reverse()                     #7일 걸리는 기능이 먼저 나가기 때문에 역순으로 만듬
#
#     top = terms.pop()           #top = 배포되는 날
#     cnt = [1]                   #배포 되는날에 완성되는 기능의 개수
#     while terms:                #남아있는 기능이 없을 때 까지
#         elem = terms.pop()      #배포되는 날의 기능과 비교할 기능
#         if elem <= top:         #비교할 기능이 배포되는 날의 기능보다 전날에 완성되면 배포할 기능의 개수 증가
#             cnt[-1] += 1
#         else:
#             top = elem          #배포되는날은 다음기능이 완성이 되는날이 되고
#             cnt.append(1)       #같은 날 배포될 기능의 개수를 초기화(=1)
#
#     answer = cnt
#     return answer

#queue(큐)
# a = []
# a.append(1)
# a.append(2)
# a.append(3)
# print(a)
# print(a.pop(0))
# print(a.pop(0))
# print(a.pop(0))
# class QueueElement:
#     def __init__(self,data,next):
#         self.data = data
#         self.next = next
#
# class Queue:
#     def __init__(self):
#         self.front = None
#         self.rear = None
#     def enqueue(self,data):
#         if self.front == None:         #Queue안에 element가 없는 경우
#             elem = QueueElement(data,None)
#             self.rear = elem
#             self.front = elem
#         else:                           #Queue안에 element가 있는 경우
#             elem = QueueElement(data,None)
#             self.rear.next = elem
#             self.rear = elem
#
#     def dequeue(self):
#         if self.front == None:
#             return None
#         else:
#             data = self.front.data
#             self.front = self.front.next
#             return data
#     def reverse(self):
#         prev = None
#         curr = self.front
#         while curr:
#             next = curr.next
#             curr.next = prev
#             prev = curr
#             curr = next
#         self.front,self.rear = self.rear,self.front
#
#
#
#
# q1 = Queue()
#
# for i in range(1,11):
#     q1.enqueue(i)
#
# q1.reverse()
# for i in range(10):
#     print(q1.dequeue())

#프로그래머스 2016년
# a = 5
# b = 24
# c = ['THU','FRI','SAT','SUN','MON','TUE','WED']
# d = [31,29,31,30,31,30,31,31,30,31,30,31]
# def solution(a, b):
#     answer = ''

#풀이
# def solution(a,b):
#     answer = ''
#     day = ['THU','FRI','SAT','SUN','MON','TUE','WED']
#     mon = [31,29,31,30,31,30,31,31,30,31,30,31]
#     total_day = 0
#
#     for i in range(a - 1):
#         total_day += mon[i]
#
#     answer = day[(total_day + b) % 7]
#     return  answer

#프로그래머스 체육복
