#내장함수
# abs
# absolute(절댓값)의 약자
# 숫자의 절댓값을 돌려준다.
# 객체가 __abs__() 메서드를 구현하는 경우
# 그에 대한 리턴값을 돌려준다.

# print("1의 절댓값:", abs(1))   # 출력: 1

# print("-3의 절댓값:", abs(-3))  # 출력: 3

# print("-.5의 절댓값:", abs(-.5))    # 출력: 0.5

# 문제 abs([-1, -3, 2])의 결과?
# 에러

#list를 상속하는 MyList 클래스 작성
# class MyList(list):
#     def __init__(self, seq=()):
#         super().__init__(seq)
#
#     def __abs__(self):
#         abslist = MyList()
#         # 숫자만 abs를 적용하여 새로운 리스트 생성
#         for i in self:
#             if type(i) in (int, float):
#                 abslist.append(abs(i))
#             else:
#                 abslist.append(i)
#         return abslist
# mylist = MyList([-1, -3, 2, "4"])
# print(abs(mylist))  # [1, 3, 2, '4']

#max, min
# max(iterable *[, key, default])
# max(arg1, agr2, *args [,key])
# min 도 위와 동일
# 1. 입력 받은 iterable(반복 가능) 객체 중 제일 큰 값 리턴
# 2. 입력 받은 인자값 중 제일 큰 값 리턴
# - min은 위의 반대

# print(max([1, 3, 4]))   # 4
# print(max(1, 2, "4"))   # TypeError
# print(max(1, 2))        # 2
# print(max(3))           # TypeError
# print(max([]))          # ValueError
# print(max([], default=0))   # 0
# print(max([1, 9], [4, 7]))  # [4, 7]
# print(max([1, 9], [4, 7], key=lambda x: sum(x)))  # [4, 7]
# print(max("abcdefg"))   # g
# print(max("a", "A"))    # a

#sum
# sum(iterable, start=0)
# iterable 항목들을 왼쪽에서 오른쪽으로 합하고 합계를 리턴한다.
# start 값은 시작값을 넘길 수 있다. (시작값은 문자열이 될 수 없다.)

# print(sum([1, 2, 3]))   # 6
# print(sum((1, 2, 3)))   # 6
# print(sum(range(4)))    # 6
# print(sum([1, 2, 3], start=6))  # 12
# print(sum(["1", "2", "3"])) # EypeError
# print(''.join(["1", "2", "3"])) # 123

#pow
# pow(base, exp[,mod])
# base의 exp 거듭제곱을 리턴한다.
# mod 값을 전달하는 경우 생성된 결과에 해당 값으로 나머지 연산을 처리해준다.

# print(pow(3, 3))        # 27
# print(pow(1.5, 0.5))    # 1.224744871391589
# print(pow(1.224744871391589, 2))    # 1.4999999999999998
# print(pow(3, 3, mod=3)) # 0
# print(3 ** 3 == pow(3, 3))  # True

#round
# round(number [, ndigits])
# number의 반올림 값을 리턴한다.
# ndigits 은 소수점 몇번째 자리부터 올릴 것인지
# 결정하는 값이다.

# print(round(30))    # 30
# print(round(30.1))  # 30
# print(round(30.5))  # 30 (부동 소수점 오차)
# print(round(30.6))  # 31
# print(round(12.656, 2)) # 12.66

#프로그래머스 64065 튜플
# s = "{{1,2,3},{2,1},{1,2,4,3},{2}}"
# def solution(s):
#     answer = []
#     l = [[]]
#     count = 0
#     l_ = []
#     for i in s:
#         if i == '}':
#             count += 1
#             l.append([])
#         if i.isdigit():
#             l[count].append(i)
#     count = 0
#     for i in range(len(l)):
#         if l[count]:
#             pass
#         else:
#             del(l[count])
#             count -= 1
#         count += 1
#         print(l)
#     l.sort(key=lambda x: len(x))
#     for i in range(len(l)):
#         answer.append(int(l[i][-1]))
#     return answer
#
# print(solution(s))

# 풀이
# 문자열 집합을 집합 리스트로 만드는 함수
# s = "{{2},{2,1},{2,1,3},{2,1,3,4}}"
# def parseSet(s:str):
#     s = s[1:-1]
#     s = s.replace(",{", " ").replace("}", "").replace("{", "")
#     s = s.split(" ")
#     slist = []
#     for sl in s:
#         slist.append(set(map(int, sl.split(","))))
#     slist.sort(key=lambda x: len(x))
# 
#     return slist
# 
# def solution(s:str):
#     sl = parseSet(s)    # 문자열 집합을 집합 리스트로 만듦
#     temp = sl[0]        # 튜플의 첫번째 집합이 됨
#     answer = [sl[0]]    # 정답 리스트
#     for i in range(1, len(sl)):
#         answer.append(sl[i] - temp)
#         temp = sl[i]
# 
#     for i in range(len(answer)):
#         answer[i] = answer[i].pop()
# 
#     return answer
