# 소수(소수점 아래)의 이진수 표현

# 십진수의 소수 표현
# p = a10^-1+b10^-2+c10^-3...

# 이진수의 소수 표현
# P = a2^-1+b2^-2+c2^-3...

# 십진수 소수를 이진수 소수로 변환
# 2를 곱했을 때 올라가는 소수점 윗 정수 부분을 그대로 나열 -> 정수 부분을 0으로 바꾸고 다시 반복
# 소수 부분이 0이 될 때까지 반복

# 십진수를 이진수 소수로 표현할 때 문제점
# 0.6의 경우 순환한다. (1/10을 2의 제곱으로 표현할 수 없기 때문)

# 이진수 소수 -> 십진수 소수 변환기
def t(n):
    answer = 0
    a = -1
    for i in n:
        answer += int(i)*2 ** a
        a -= 1
    return answer
#
#
# n = input()
# print(t(n))

def point_dtob(decimal):
    # 소수부를 정수로 계산하기 위해
    # 소수부의 제수를 구한다.
    divisor = 10
    while divisor < decimal:
        divisor *= 10

    binary = ""
    while (decimal > 0 and len(binary) < 23):
        # 소수부 * 2
        decimal *= 2
        # 정수부를 구하여 이진수 자릿수를 추가
        binary += str(decimal // divisor)
        # 정수부를 제외 시킴
        decimal %= divisor

    return binary
# n = int(input())
# print(point_dtob(n))

# 컴퓨터에서의 실수 표현

# 고정 소수점(fixed point)
# 기존 정수 연산을 그대로 사용할 수 있기 때문에 빠르고 간단
# 10자리 이상의 실수를 표현 x

# 부동 소수점(floating point)
# 하나의 실수를 부호, 지수부, 가수부(유호수, 분수값)로 나누어 표현하고 저장
# 부동 소수점은 부호를 S, 지수를 E, 가수를 M이라고 했을때 실수 V는 다음과 같이 나타낼 수 있다.
# V = -1^S * M * 2^E

# 지수와 바이어스(bias, 편향값)
# 바이어스 표현법은 2의 보수와 전혀 다른 형태
# 원래라면 0000000은 0이어야 하지만 -127이다.
# 이진수 최대값인 255(11111111)는 다른 목적으로 사용된다.
# 지수부 = E + 127

# 가수(mantissa)
# 가수는 n.nnnn.... 형식으로 나타나는 실수의 유효수
# 정규화 과정을 거쳐 구해진다.
# 십진수
# 123.456 = 1.23456 * 10^2
# 0.0123 = 1.23 * 10^-2

# 이진수
# 100101.101 = 1.00101101 * 2^4
# 이때 정수부 1은 항상 고정이므로 실제 저장되는 가수부는 00101101이며
# 가수부의 나머지 부분은 0으로 채워짐

# print(0.1+0.2==0.3)
